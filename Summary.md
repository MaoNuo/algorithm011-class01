# 算法训练营总结

## 1.学习方法
* 算法的学习是一种将学过的知识运用到现实场景的过程，所以不要局限于书本上学到的知识，多去思考这个题的深层内涵，
    并且建模将问题套在知识上。在进行了多次的练习和总结之后，会慢慢的形成经验，从而能够越来越熟练的解决问题

* 算法学习的误区:题目只做一遍，看过等于会做，通过等于精通。不能陷入这样的误区中，对于每一个问题，进行多几次
    的练习可以巩固自己对相关知识的掌握。五毒神掌练题法:将每个题目分成不同的几个阶段，进行不断的反复的练习
    每次遇到这个题目的时候，已一种全新的思路去重新思考这个问题，也许可以看到不一样的东西，也许可以更快的
    想到上次没有想到的东西，反复和重复是学习过程中最为无趣但是最为有效的办法
  
* 学习的过程中，总是会碰见新知识，或者碰见不会做的题，这个时候不能死磕，因为那么多题等着你，不能吊死在一棵树上
    在之后的学习中我们没有在学校中的老师一样可以随时给你指导，这个时候就需要自己看题解，看讨论，学习别人的套路，
    然后通过上述的五毒神掌等方法将其注入到自己的脑子里，把其变成自己的东西。在阅读他人的思路和他人的代码的时候，
    多去思考，而不是只是单纯的将代码抄到自己的题板上，通过这个过程，同时也能接触到别的高手的一些比较高级的比较优雅
    的写法，也对自己今后的代码编写会产生很大的帮助
    
## 2.各种算法的题目
* 算法是什么？ 是一种解决问题的方式。首先程序员需要去理解这个题目的中心思想，然后以代码的形式将其交给计算机。
    最后这个问题要通过计算机来解决，所以我们不能以我们的视角来看问题，而是以计算机的视角来判断这个问题。
    
* 计算机的视角。计算机是一种非常单纯的东西，计算机能够执行的只有循环和递归，所以在碰到一个问题的时候，先思考这个
    问题的重复性，这样才是一种计算机的思考方法。将一个大问题分解成一个一个的相似小问题，最后再将小问题给结合到一起
    就变成了大问题的解决方法。这和高中学习的数学归纳法非常相似。
    
* 数学归纳法:1.确定基础状态。2.假设k状态成立。3.以k状态为基础计算k+1状态是否成立。在递归中，我们的思考主要以第三步
    为主，也就是我们通过上一层得到的结果来计算这一层的结果，这就是数学归纳法的思想，也是一种非常典型的计算机的思考
    问题的方法
    
* 一些第一次见的算法:在算法的学习过程中，肯定是会有没有见过的算法，我们需要的不是去想这个是怎么来的，而是去思考他的内涵，
    他的逻辑，为什么可以通过这样的方法得到这样的结果，中间的每一步过程都代表了什么。去理解算法的过程是一个很重要的环节，
    因为有时候你可以通过中间的某些细节和思考方式来得到其他问题的解决办法。
    
## 3.一些比较典型的需要掌握的算法
* 递归:如上所述，递归是计算机解决问题的一种最基本的处理模式。在我们找到重复子问题之后，我们可以通过递归的方法将其一层一层的
    向下挖掘，最终得到我们想要的结果
```
public void recur(int level) {
    //1.terminate state
    if (level == out) { return; }

    //2.当前层处理方式
    doSomething();
    //3. drill down
    recur(level + 1);   
    //4. restoke the state         
}
```
* 动态规划:动态规划是一个比较高级的循环方式。从递归的代码中我们可以看出，其实递归是一个很简单的过程，判断，执行，下一层，回复。
    在一些递归中，我们不需要恢复当前层的状态，这个时候我们可以直接使用动态规划来进行操作
>    1，判断:可以根据for或者while的判断条件来执行
>    2.执行:在循环体中来执行这一段的代码
>    3.递归到下一层:通过最后的处理来对其进行判断

   由上述可以看到，其实可以通过一种比较简单的方法来进行复杂的递归的操作，这就是动态规划和递归相似的地方
   
* 高级动态规划:动态规划中，我们使用一个数组Array来进行保存每个状态中的结果，这个时候，就如同数学归纳法中我们需要明确我们要
    证明的题意一样，我们需要确定我们保存的结果中的意义。如同，在斐波拉契数列中，我们在下标n处存放的就是第n项的数，然后我们通过
    这个数来计算下几个数。再比如，在一些字符串的比较中，我们可以用数组的下标来表示以该下标结束的子字符串，然后进行对其他字符串的
    比较或者一些别的计算。
    动态规划中，要明确自己要的是什么东西，才能更好的去理解和得到自己想要的目标
    
* 图和树的搜索:基础搜索有DFS和BFS，其实两者并没有什么区别，都是对于每个节点进行一次搜索的简单搜索方式。但是在图的搜索中，因为
    可能会存在环的原因，我们需要一个额外的set去记录已经遍历过的节点，避免反复遍历进入无限循环
* 一些高级搜索:比如说最优路径搜索A*，还有带价值的搜索法，都是在DFS和BFS的基础上进行的一些性能升级，他们可以通过节点的优先度来
    控制下一个搜索的节点，使得更早的找到Goal，从而剪掉一些偏远的节点
    
* 搜索的基础原理:首先我们需要两个列表，OpenList和ClosedList，用来保存已经遍历到的节点和将要保存的节点，之后每次从OpenList中
    取出队首的节点，将其放入ClosedList中，再将与其相邻的节点根据搜索方法的不同放到OpenList中(例如DFS会将相邻的节点放到OpenList的队首，
    而BFS则会放到队尾。A*等算法会在相邻节点放入OpenList之后根据价值函数重新对其进行排序)，一直到我们搜索到Goal之后结束循环
    
* 排序算法:最基础的排序算法都是以比较和交换为基础，每次循环找到当前未排序队列中的最大或最小值，将其放到正确位置后进行下一层循环，
    时间复杂度基本为O(N^2)。高级一点的排序算法是以递归或者堆等数据结构来进行统一的排序，然后最后整合，时间复杂度一般为O(NlogN)
    
* 排序算法的稳定性:指的是在排序后，会不会改变相同大小的元素的相对顺序。
>* 对于基础排序，由于以比较和交换为前提，所以都是稳定的，因为同样大小的元素会通过先后顺序进入排序之后的数组，此时我们可以通过设定进入的
>顺序来使其达到稳定
>* 对于堆排和归并排序，他们也是稳定的，因为堆也是一个通过比较进行排序的方法，不会改变顺序。而归并排序由于其向下递归的顺序性，他也是稳定的
>* 然而对于快速排序，他并不是稳定的，因为1.快速排序根据pivot来决定左右两个数组的长度，在我们移动左右两个数组中的元素的时候，可能会改变同样元素的
>   出现顺序，所以快速排序并不是稳定的

# 4.一些很少使用但是非常有用的算法和数据结构
* 并查集:并查集是一个以数组为基础的数据结构，他可以将同一个系统或者说同一个结构的元素合并到同一个目录下，非常适合朋友圈或者岛屿数量这样的题目
* 字典树:字典树是一个以多叉树为基础的数据结构，广泛用于查询引擎搜索时的推荐中。他通过将一个个字符放到树的子节点中，来判断该输入字符串是否存在，
    可以进行对含有该前缀的字符串的推荐
* 布朗过滤器:这是一个比较简单的过滤器，他是由一组BitSet组成的。对于每一个输入，他会使用一个函数将其分成一个一个的bit，然后存储到BitSet中。在
    查询操作时，查找该函数输出的所有字符是否都被标记为存在。如果有一个不存在，那么可以保证该数据一定不存在，但是如果存在，布朗过滤器只能说该数据可能
    存在，因为会存在由于大量数据导致的覆盖性问题。布朗过滤器广泛运用与DB的前驱过滤中
    
# 5.一些很重要但是由于太难不用去实现的数据结构
* 平衡树:由于二叉搜索树有时会退化成链表或者说由于高度不一致导致的不稳定，我们会通过一些方法使其达到一个平衡的状态
* 旋转:旋转是指，通过旋转某些节点使其达到高度减少的作用的操作
```aidl
|        G             P        |     G                   P         |
|       /            /   \      |      \                /   \       |
|      P       ->   N     G     |        P    ->       G     N      |
|     /  \               /      |       /  \            \           |
|    N    C             C       |      C    N            C          |
```
* 关于旋转之后节点N的兄弟节点C的去向:注意二叉搜索树中的大小关系，在原树中，有G > C > P的关系，所以在旋转之后也要保持
    这个关系，所以在旋转之后C会在G的左侧
* 还有比较复杂的旋转:以上面的两种旋转为基础，将其旋转到这个情况之后再次旋转

* AVL:AVL是一种严格自平衡的数据结构。他会对每一个节点额外存储一个新的值，用于计算该节点的左右子树的高度差，当期偏离了设定的高度差的时候，
    会通过旋转来保持自身的平衡。缺点:1.额外的存储可能会很大。2.旋转操作可能会很频繁，浪费时间。
    所以AVL通常会应用于DB这样的插入少，查询多的结构上
* 红黑树:和AVL不同，红黑树不是一个严格自平衡的数据结构，他通过5条定理来保证自己的平衡
>1. 根节点一定是黑色
>2. 叶子节点(NIL或NULL)一定是黑色
>3. 红色节点的子节点一定是黑色
>4. 以树中的每一个节点为起点，到每一个叶子节点，所经过的黑色节点的数量相同
>5. 节点的颜色非黑即红
* 通过以上5点，可以发现，红黑树不是完全平衡的，但是是黑色节点完全平衡的，然后根据红色节点的子节点不能是红色这条，可以知道每一个节点，
    他的左右子树的高度差不会超过黑色节点的数量。红黑树是以这样的规律来保持平衡的
* 红黑树的自平衡操作:1，变色，在插入一个新节点之后，可能会出现违反第三条的情况，这种时候需要递归的进行变色。2.旋转，同上，会将不平衡的节点进行
    旋转操作
    
    
    
# 6.总结
* 算法训练营中，更多的我学到的不是算法和解决问题的方法，而是一种学习方法。在这段时间内，我改掉了很多之前的错误的效率地下的学习方法，
    从而改进了自己的学习效率，这对我之后的学习也会起很大的帮助
* 学习中更重要的不是将一个新知识硬塞进脑子里，这样不仅效率低下，也很难真正的掌握这个知识的精髓。而是更应该去注重知识内部的体系，通过思考和
    实际的动手去操作，来加深自己对这个知识的理解，从而不是我们学会这个知识，而是真正的掌握这种思想，这样在今后的学习中，也能更自然的蹦出
    这种想法，来提升自己的学习和工作效率。
    
