学习笔记

利用二分查找找出无序数组中的无序的地方
该数组可以分解成两段有序的数组，其中前面半段的数组大于后面的数组
左端节点（下标为0）的值一定大于无序的起点，所以可以以这个来判断目标点的位置
当mid的值比左端小时，说明该点在右半段的数组中，目标点在左侧，所以lo = mid + 1；
此外的情况，也就是mid的值大于或等于左端的值时，说明左半段有序，则目标点在右侧，所以hi = mid - 1；

···
class Binary-search {
    public int search(int[] nums) {
        int lo = 0, hi = nums.length - 1;
        while (lo <= hi) {
            int mid = (lo + hi) >>> 1;
            //判断中点和两边
            //如果中点值大于左点值，则说明左半段有序，目标在右半段
            if (nums[mid] >= nums[0]) {
                lo = mid + 1;
            } else {
                //如果中点值不比左边大，则说明右半段有序，目标在左半段
                hi = mid - 1;
            }
        }
        //最终返回lo值
        //最终判断中，mid的值会与lo相等，此时lo与hi相等
        //hi有两种情况，1：目标点。此时会进入else的判断中，lo不变，为目标点
        //2：目标点前的数。此时进入if判断，lo会自增，为目标点
        return lo;
    }
}
···

广度优先和深度优先
1.广度优先以层为单位，优先遍历该层的所有节点，所以一般使用队列作为额外空间进行存储接下来要遍历的节点
2.深度优先会首先将一个分叉走到底，走到底后需要返回到该父节点继续遍历下一节点，所以递归最为合适。或者使用双端队列每次将该点的子节点添加到该队列的头部

应用范围
1.广度优先适合路径问题，结合贪心或者动态规划，更加的直观和简洁
2.深度优先由于通常使用递归，在代码上会比较简洁，只是比较晦涩难懂

贪心算法
1.思想：对于一个可以分解成若干个各不相干的小问题的大问题而言，每一步的最优解的组合最后一定是该大问题的最优解
2.方法：将大问题分解成小问题，然后对于每一个小问题进行求解，最后整合得到答案

总结
1.对于计算机语言中的算法而言，计算机只能处理判断，循环和递归，所以将大问题分解成小问题是所有题的中心思想，也是必须要掌握的技能
2.对于一个问题而言，首先需要分析的是他的结构与层次，然后思考应该使用什么方法。
3.对于很复杂的问题，不要一步一步死磕到底，不仅没有效率，还容易出错，最重要的是找出这个问题背后的一个一个子问题，然后对于子问题进行求解，这样就可以很显而易见的使用贪心等算法了
