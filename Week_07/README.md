# 学习总结

## 1.字典树和并查集
* 1.1 字典树：将多叉树转换为一个字典，其中每个节点可以保存到该点所组成的单词的各种信息，例如cost，例如频率
                节点与节点之间的边，即表示该点的路径，简单明了
* 1.2 字典树的应用：多用于搜索引擎的推荐，或者入力字符的判断
    
* 1.3 并查集：简单的说，就是讲很多个分开的点进行结合，其中包含着不同的小团体，可以判断哪个点是哪个小团体的
                数据结构。拥有parent函数来查找小团体的头头，union函数来让某点或者某点带领的小团体加入另一个小团体
* 1.4 并查集的应用：比如棋盘的分割，岛屿数量，朋友圈等这种一看就带有小团体性质的题目，非常适合使用并查集来解决问题
* 1.5 并查集的难点：对于并查集的理解，实现非常简单，更多的需要来思考什么情况下可以让某些点成为一个小团体。因为并查集并不带有这方面的功能

## 2.高级搜索
* 2.1 对于普通的DFS，BFS而言，搜索非常的麻烦，因为在一个规定的起点和终点内，并不是所有的点都需要你去遍历，
        然而DFS和BFS并没有对点有筛选功能，也就是没有剪枝，这导致了在一些很复杂的情况下可能会使用非常多的时间，
        DFS可能会因为层数太多导致栈溢出，所以剪枝或者一些高级搜索非常的需要
* 2.2 双向BFS：双向BFS其实也是剪枝的一种类型，因为对于两头而言，我们总是只搜索当前队列中节点较少的那一边，那么带来的
        结果自然就是有一些非常偏远的边边角角我们并不会去进行搜索。将整个状态递归树画出来可以发现，他会比单向BFS要来的瘦来的窄
        所以双向BFS也是一种剪枝，但是因为需要同时维护两头的队列和set，所以也是一种以空间换时间的算法
* 2.3 A\*搜索：不同于DFS和BFS，A*搜索的特点是对每一个入队列的节点进行一个价值评估，然后重新排序整个队列中的优先顺序，每次都会先搜索
        价值较高，或者说离目标最近的节点，这样带来的结果是，我们通过这种算法能够更快的找到目标点。因为在更新价值（cost）的时候，
        有一些太偏远的点可能永远不会排到前面，也就是说永远不会，或者说不可能太早的被搜索到，这样来节省搜索的时间
* 2.4 A\*搜索：但是A*搜索一个比较重要的地方是，如何去评估这个点的价值，或者说再到达一个新的未探索过的节点时，如何来更新已有节点的cost。
        解决这些问题后，通过优先队列即可比较好的解决这类搜索问题。
        
## 3.自平衡树
* 3.1 自平衡树的概念：对于一般的<u>二叉搜索树</u>而言，会出现因为不够平衡而导致搜索时间退化到接近链表水平，这和当时发明树这种结构的初衷相违，
        所以需要一种方法，或者说一种新的数据结构来解决这方面的问题，可以通过自旋转或者其他的方法保证该树的各种操作都可以保持在一个平均水准
   
* 3.2 AVL：AVL树是一种严格自平衡的树，他的特点是在每一个节点都保存一个平衡因子，来计算当前树是否平衡。

* 3.2.1 平衡因子：AVL树的平衡因子是通过该节点的左右子树的*高度*来决定的，一般会设定为{-1, 0, 1}，可以根据实际需求进行调整
* 3.2.2 不平衡时的平衡方法：通过旋转，一共有4种旋转方法，分别对应着4种情况。当不平衡的节点表现为左左或者右右，即从上到下为有序状态时，只需要一次
        旋转，即将中间节点旋转成为该子树的根即可。而当该子树表现为中间节点并不是有序中间节点时，需要先通过一次旋转将中间节点的子节点旋转到上面来，
        使其变换成为上一种情况的左左或者右右的状态下，再通过一次旋转使其平衡。
        
* 3.3 红黑树：由于AVL是一种严格平衡的树，使得其操作，旋转的次数变得异常多。实际情况下也需要一种比较马虎一点的结构，使其在必要时平衡一下即可
* 3.3.1 红黑树的特点：每一个节点都包含一个字节来判断该节点的颜色，红或者黑。其中，根节点和叶子节点（NULL）必须为黑色。红色节点不能相邻，任何节点
        到达叶子节点所经过的黑色节点树都是一定的。这种特性使得对于树的每一个节点而言，较深的子树的深度不会超过较浅的那一方的2倍，并且需要通过旋转
        保持自平衡的次数相对于AVL来说会少特别多
        
* 3.3.2 红黑树与AVL的比较：首先，对于额外存储的数据而言，AVL需要存储一个int，用来存储两边的深度差，而红黑树只需要一个bit来存储该节点是红还是黑，
        红黑树的额外空间非常的少。第二，由于AVL是一种严格平衡的结构，所以在插入和删除的时候，可能都需要大量的旋转操作来保持平衡，这使得该结构的插入
        和删除所用的时间变得非常长。第三，由于AVL严格自平衡，所以在查找数据来说他的时间会非常的快，而红黑树没有AVL那么严格，所以查找可能会慢一点，
        但是同时也使得红黑树的插入和删除操作变得快不少
* 3.4 AVL和红黑树格子的应用场景：AVL严格自平衡，所以比较适合查询较多而插入删除较少的数据结构，例如DataBase。
                             红黑树的插入删除会比AVL快，所以比较适合写操作较多而读操作较少的结构，例如Java中的HashMap等数据结构
